#
# Definición de los métodos para predecir el estado de un dispositivo Lux
#


import connexion
from datetime import date, datetime
from typing import List, Dict
from six import iteritems
from ..util import deserialize_date, deserialize_datetime

import MySQLdb

import pandas as pd

import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPClassifier
from sklearn import metrics


# Función para importar el dataset desde la tabla dwh
def getDataFromDWH(luxId):
	dbname_hist = "ratio_dwh"
	dbhost_hist = "localhost"
	dbport_hist = 3306
	dbuser_hist = "root"
	dbpass_hist = "root"
	table_hist = "events_hist"

	print("Conectando al DWH")
	try:
		conn = MySQLdb.connect(host=dbhost_hist, port=dbport_hist, user=dbuser_hist, passwd=dbpass_hist, db=dbname_hist)
	except:
		print("Error conectando al DWH")
		return -1

	print("Extrayendo datos del DWH para el dispositivo",luxId)
	# Acá hay que habilitar la consulta para un dispositivo en particular con el query que está comentado
	#events = pd.read_sql('select * from ' + table_hist + ' where LUX_ID=' + luxId, con=conn)
	events = pd.read_sql('select * from ' + table_hist, con=conn)
	conn.close()
	return events

def get_suggested_state(LUX_ID):
    """
    Consultar el estado sugerido de un dispositivo Lux
    Método para consultar el estado sugerido de un dispositivo DqR Lux, en un momento dado
    :param LUX_ID: ID del dispositivo
    :type LUX_ID: int

    Otros parametros necesarios a solicitar por medio de sql:
    :param WEEKDAY: Dia de la semana, de 0 (Lunes) a 6
    :type WEEKDAY: int
    :param MINDAY: Minuto del día, de 0 a 1439
    :type MINDAY: int
    :param LIGHT_LUX_1m: Estado del sensor de luminosidad en el minuto anterior
    :type LIGHT_LUX_1m: int
    :param SOUND: Valor del sensor de sonido
    :type SOUND: float
    :param MOVEMENT: Valor del sensor de movimiento
    :type MOVEMENT: float
    :param MOVEMENT_1m: Valor del sensor de movimiento
    :type MOVEMENT_1m: float
    :param MOVEMENT_5m: Valor del sensor de movimiento
    :type MOVEMENT_5m: float
    :param MOVEMENT_15m: Valor del sensor de movimiento
    :type MOVEMENT_15m: float

    :rtype: None
    """
    return LUX_ID

    X_new_test = pd.DataFrame([[ WEEKDAY, MINDAY, LIGHT_LUX_1m, SOUND, MOVEMENT, MOVEMENT_1m, MOVEMENT_5m, MOVEMENT_15m ]],columns=luxState_feature_names)
    clf_predict_new_test = models[LUX_ID][0].predict(X_new_test)
    new_test = { "suggestedState": clf_predict_new_test }
    return str(clf_predict_new_test)


def get_suggested_state_change(LUX_ID):
    """
    Consultar cambio de estado sugerido de un dispositivo Lux
    Método para consultar si hay un cambio estado sugerido  de un dispositivo DqR Lux, en un momento dado
    :param LUX_ID: ID del dispositivo
    :type LUX_ID: int

    Otros parametros necesarios a solicitar por medio de sql:
    :param WEEKDAY: Dia de la semana, de 0 (Lunes) a 6
    :type WEEKDAY: int
    :param MINDAY: Minuto del día, de 0 a 1439
    :type MINDAY: int
    :param LIGHT_LUX_1m: Estado del sensor de luminosidad en el minuto anterior
    :type LIGHT_LUX_1m: int
    :param SOUND: Valor del sensor de sonido
    :type SOUND: float
    :param MOVEMENT: Valor del sensor de movimiento
    :type MOVEMENT: float
    :param MOVEMENT_1m: Valor del sensor de movimiento
    :type MOVEMENT_1m: float
    :param MOVEMENT_5m: Valor del sensor de movimiento
    :type MOVEMENT_5m: float
    :param MOVEMENT_15m: Valor del sensor de movimiento
    :type MOVEMENT_15m: float

    :rtype: None
    """
    return str(2)
    X_new_test = pd.DataFrame([[ WEEKDAY, MINDAY, LIGHT_LUX_1m, SOUND, MOVEMENT, MOVEMENT_1m, MOVEMENT_5m, MOVEMENT_15m ]],columns=luxState_feature_names)
    clf_predict_new_test = models[LUX_ID][1].predict(X_new_test)
    new_test = { "suggestedStateChange": clf_predict_new_test }
    return str(clf_predict_new_test)


# Función para entrenar
def do_training(LUX_ID):
	"""
	Realizar el entrenamiento para un dispositivo Lux
	Método para realizar el entrenamiento de la RNA para un dispositivo Lux en particular
	:param LUX_ID: ID del dispositivo
	:type LUX_ID: int
	:rtype: None
	"""

	# Obtener los datos del dwh
	df_events = getDataFromDWH(LUX_ID)
	try:
		print("Se obtuvieron",df_events.shape[0],"registros")
	except:
		print("Imposible entrenar sin datos")
		return -1

	# Borrar las columnas que son irrelevantes
	del df_events['TIMESTAMP']
	del df_events['YEARDAY']
	del df_events['HOUR']
	del df_events['MINUTE']
	del df_events['TEMPERATURE']
	del df_events['LIGHT']
	del df_events['LUX_ACS']
	del df_events['POT_ACS']
	# Descomentar cuando haya creado la columna en el dwh
	#del df_events['LUX_ID']

	# Ajustes de variables
	df_events['MOVEMENT'] = df_events.MOVEMENT.astype(int)

	# Generación de nuevas variables
	df_events['LIGHT_LUX_1m'] = df_events.LIGHT_LUX.shift(1)
	df_events['MOVEMENT_1m'] = df_events.MOVEMENT.shift(1)
	df_events['MOVEMENT_5m'] = df_events.MOVEMENT.rolling(5).sum() / 5
	df_events['MOVEMENT_15m'] = df_events.MOVEMENT.rolling(15).sum() / 15
	df_events['LUX_SWITCH'] = df_events.LUX_ON.diff()
	df_events.dropna(inplace=True)

	# Impresión de la proporcion on/off en el dwh
	print("Proporción de datos en el DWH:")
	df_events.LUX_SWITCH.value_counts(normalize=True)


	# --- Entrenamiento Inicial del modelo de estado ---
	print("Entrenamiento del modelo de cambio de estado")
	print("Preparación de los datos")
	luxState_feature_names = ['WEEKDAY', 'MINDAY', 'LIGHT_LUX_1m', 'SOUND', 'MOVEMENT', 'MOVEMENT_1m', 'MOVEMENT_5m', 'MOVEMENT_15m']
	luxState_goal_names = ['LUX_ON']
	luxState_features = df_events[luxState_feature_names].values     # Columnas del predictor (5 X m)
	luxState_goal = df_events[luxState_goal_names].values            # Clase predecida (1=verdadero, 0=falso) column (1 X m)
	split_test_size = 0.30                                           # 0.30 es 30%, el tamaño para pruebas
	luxState_features_train, luxState_features_test, luxState_goal_train, luxState_goal_test = train_test_split(luxState_features, luxState_goal, test_size=split_test_size)

	print("Lux Activo en el total           : {0} ({1:0.2f}%)".format(len(df_events.loc[df_events['LUX_ON'] == 1]), (len(df_events.loc[df_events['LUX_ON'] == 1])/float(len(df_events.index))) * 100.0))
	print("Lux Inactivo en el total         : {0} ({1:0.2f}%)".format(len(df_events.loc[df_events['LUX_ON'] == 0]), (len(df_events.loc[df_events['LUX_ON'] == 0])/float(len(df_events.index))) * 100.0))
	train_state_on = len(luxState_goal_train[ luxState_goal_train == 1])
	train_state_off = len(luxState_goal_train[ luxState_goal_train == 0])
	print("Lux Activo en entrenamiento      : {0} ({1:0.2f}%)".format(train_state_on, train_state_on/float(len(luxState_goal_train)) * 100.0))
	print("Lux Inctivo en entrenamiento     : {0} ({1:0.2f}%)".format(train_state_off, train_state_off/float(len(luxState_goal_train)) * 100.0))
	test_state_on = len(luxState_goal_test[ luxState_goal_test == 1])
	test_state_off = len(luxState_goal_test[ luxState_goal_test == 0])
	print("Lux Activo en test               : {0} ({1:0.2f}%)".format(test_state_on, test_state_on/float(len(luxState_goal_test)) * 100.0))
	print("Lux Inctivo en test              : {0} ({1:0.2f}%)".format(test_state_off,test_state_off/float(len(luxState_goal_test)) * 100.0))
	print("")

	print("Entrenando RNA-Classifier para modelo de estado...")
	clf_model_state = MLPClassifier()
	clf_model_state.fit(luxState_features_train, luxState_goal_train.ravel())

	# Performance del modelo de estado con datos de entrenamiento
	clf_predict_state_train = clf_model_state.predict(luxState_features_train)
	print("Precisión del modelo de estado en entrenamiento: {0:.4f}".format(metrics.accuracy_score(luxState_goal_train, clf_predict_state_train)))

	# Performance del modelo de estado con datos de prueba
	clf_predict_state_test = clf_model_state.predict(luxState_features_test)
	print("Precisión del modelo de estado en test: {0:.4f}".format(metrics.accuracy_score(luxState_goal_test, clf_predict_state_test)))

	# Matriz de confusión del modelo de estado
	print("Matriz de confusión del modelo de estado:")
	print("{0}".format(metrics.confusion_matrix(luxState_goal_test, clf_predict_state_test, labels=[1, 0])))

	# Reporte de clasificación del modelo de estado
	print("Reporte de clasificación del modelo de estado:")
	print(metrics.classification_report(luxState_goal_test, clf_predict_state_test, labels=[1,0]))


	# --- Entrenamiento Inicial del modelo de cambio de estado ---
	print("Entrenamiento del modelo de cambio de estado")
	print("Preparación de los datos")
	luxSwitch_feature_names = ['WEEKDAY', 'MINDAY', 'LIGHT_LUX_1m', 'SOUND', 'MOVEMENT', 'MOVEMENT_1m', 'MOVEMENT_5m', 'MOVEMENT_15m' ]
	luxSwitch_goal_names = ['LUX_SWITCH']
	luxSwitch_features = df_events[luxSwitch_feature_names].values        # Columnas predictoras
	luxSwitch_goal = df_events[luxSwitch_goal_names].values               # Clase predecida (1, 0, -1)
	split_test_size = 0.30                                                # 0.30 es 30%, el tamaño para pruebas
	luxSwitch_feat_train, luxSwitch_feat_test, luxSwitch_goal_train, luxSwitch_goal_test = train_test_split(luxSwitch_features, luxSwitch_goal, test_size=split_test_size)

	totales_switch_on = len(df_events.query('LUX_SWITCH == 1'))
	totales_switch_stale = len(df_events.query('LUX_SWITCH == 0'))
	totales_switch_off = len(df_events.query('LUX_SWITCH == -1'))
	print('Totales:')
	print("Prendidas        : {0} ({1:0.2f}%)".format(totales_switch_on, totales_switch_on/float(df_events.shape[0]) * 100.0))
	print("Sin cambios      : {0} ({1:0.2f}%)".format(totales_switch_stale, totales_switch_stale/float(df_events.shape[0]) * 100.0))
	print("Apagadas         : {0} ({1:0.2f}%)".format(totales_switch_off, totales_switch_off/float(df_events.shape[0]) * 100.0))
	train_switch_on = len(luxSwitch_goal_train[ luxSwitch_goal_train == 1])
	train_switch_stale = len(luxSwitch_goal_train[ luxSwitch_goal_train == 0])
	train_switch_off = len(luxSwitch_goal_train[ luxSwitch_goal_train == -1])
	print('Set de entrenamiento:')
	print("Prendidas        : {0} ({1:0.2f}%)".format(train_switch_on, train_switch_on/float(luxSwitch_goal_train.shape[0]) * 100.0))
	print("Sin cambios      : {0} ({1:0.2f}%)".format(train_switch_stale, train_switch_stale/float(luxSwitch_goal_train.shape[0]) * 100.0))
	print("Apagadas         : {0} ({1:0.2f}%)".format(train_switch_off, train_switch_off/float(luxSwitch_goal_train.shape[0]) * 100.0))
	test_switch_on = len(luxSwitch_goal_test[ luxSwitch_goal_test == 1])
	test_switch_stale = len(luxSwitch_goal_test[ luxSwitch_goal_test == 0])
	test_switch_off = len(luxSwitch_goal_test[ luxSwitch_goal_test == -1])
	print('Set de pruebas:')
	print("Prendidas        : {0} ({1:0.2f}%)".format(test_switch_on, test_switch_on/float(luxSwitch_goal_test.shape[0]) * 100.0))
	print("Sin cambios      : {0} ({1:0.2f}%)".format(test_switch_stale, test_switch_stale/float(luxSwitch_goal_test.shape[0]) * 100.0))
	print("Apagadas         : {0} ({1:0.2f}%)".format(test_switch_off, test_switch_off/float(luxSwitch_goal_test.shape[0]) * 100.0))
	print("")

	print("Entrenando RNA-Classifier para modelo de cambio de estado...")
	clf_model_switch = MLPClassifier()
	clf_model_switch.fit(luxSwitch_feat_train, luxSwitch_goal_train.ravel())

	# Performance con datos de entrenamiento
	clf_predict_switch_train = clf_model_switch.predict(luxSwitch_feat_train)
	print("Precisión del modelo de cambio de estado en entrenamiento: {0:.4f}".format(metrics.accuracy_score(luxSwitch_goal_train, clf_predict_switch_train)))

	# Performance con datos de prueba
	clf_predict_switch_test = clf_model_switch.predict(luxSwitch_feat_test)
	print("Precisión del modelo de cambio de estado en test: {0:.4f}".format(metrics.accuracy_score(luxSwitch_goal_test, clf_predict_switch_test)))

	# Matriz de confusión
	print("Matriz de confusión del modelo de cambio de estado:")
	print("{0}".format(metrics.confusion_matrix(luxSwitch_goal_test, clf_predict_switch_test, labels=[1, 0, -1])))

	# Reporte de clasificación
	print("Reporte de clasificación del modelo de cambio de estado:")
	print(metrics.classification_report(luxSwitch_goal_test, clf_predict_switch_test, labels=[1,0,-1]))

	models.update({LUX_ID: [clf_model_state, clf_model_switch]})


# ---- Inicio de la API ---
#
# No se hace training inicial. Cuando un dispositivo se marque para uso inteligente, se debe llamar
# al método train con el parametro LUX_ID
#
models = {} 
