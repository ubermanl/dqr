#
# Definición de los métodos para predecir el estado de un dispositivo Lux
#

import connexion
from datetime import date, datetime
from typing import List, Dict
from six import iteritems
from ..util import deserialize_date, deserialize_datetime
import subprocess 
import MySQLdb
from os import remove

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPClassifier
from sklearn import metrics
from sklearn.externals import joblib


#------- Acá empiezan las definiciones auxiliares para soportar los los métodos que están publicados -------#

minMax = { 
	#'light': [df_events.min()[2], df_events.max()[2]], 
	#'sound': [df_events.min()[4], df_events.max()[4]],	
	'light': [0, 1300], 
	'sound': [20, 120],
	'day':   [ 0, 6 ],
	'hour':  [ 0, 23 ]
	}

# Funcion para pasar de sensor_id a nombre
def sensorIdToStr(sensor_id):
	sensors = { 
		1: 'LUX_ACS',
		2: 'LIGHT',
		3: 'MOVEMENT',
		4: 'SOUND',
		5: 'TEMPERATURE'
	}	
	return sensors[sensor_id]

# Función para normalizar entre -1 y 1 en base a máximos y mínimos de un sensor	
def normalizar(min, max, value):
    return 2*(value - min)/(max - min) - 1

# Función para desnormalizar
def desnormalizar(min, max, value):
    return (value+1)*(max - min)/2 + min

# Conexión a la BBDD
def getDBConnection():
	dbname = "ratio_dev"
	dbhost = "localhost"
	dbport = 3306
	dbuser = "root"
	dbpass = "root"
	try:
		conn = MySQLdb.connect(host=dbhost, port=dbport, user=dbuser, passwd=dbpass, db=dbname)
		return conn
	except:
		print("Error connecting to database",dbname)
		return -1

# Función para obtener los dispositivos válidos (registrados, no borrados y activos)
def getValidDevices():
	"""
	Update the list of existing devices based on what's on the database
	"""
	conn = getDBConnection()
	cur = conn.cursor()
	cur.execute('select id from devices where deleted = 0 and disabled = 0')
	devices = [ row[0] for row in cur.fetchall() ]
	conn.close()
	return devices

# Función para obtener el device al que pertenece un modulos
def getOwnerDevice(moduleId):
	conn = getDBConnection()
	cur = conn.cursor()
	cur.execute('select device_id from device_modules where id = '+str(moduleId))
	device = cur.fetchall()[0][0]
	conn.close()
	return device
	
# Función para obtener los modulos válidos
def getValidModules():
	"""
	Update the list of existing modules based on what's on the database
	"""
	conn = getDBConnection()
	cur = conn.cursor()
	cur.execute('select id from device_modules')
	modules = [ row[0] for row in cur.fetchall() ]
	conn.close()
	return modules

# Función para importar el dataset desde las tablas de la BBDD
def getDataFromDB(deviceId, moduleId, mode):
	
	device_events_tbl = "device_events"
	device_event_sensors_tbl = "device_event_sensors"
	device_modules_tbl = "device_modules"

	# Extracción de datos
	print("Extracting events data for module",moduleId)
	conn = getDBConnection()
	from_stm = 'FROM ' + device_events_tbl + ' de LEFT JOIN ' + device_event_sensors_tbl + ' des ON de.id=des.device_event_id '
	if mode == "months":
		where_stm = 'WHERE device_id = ' + str(deviceId) + ' AND module_id = ' + str(moduleId) + ' AND ts > DATE_SUB(UTC_TIMESTAMP, INTERVAL 90 DAY)'
	else:
		where_stm = 'WHERE device_id = ' + str(deviceId) + ' AND module_id = ' + str(moduleId) + ' AND ts > DATE_SUB(UTC_TIMESTAMP, INTERVAL 16 MINUTE)'
	df_events_qry = pd.read_sql('select ts, state, sensor_type_id, value ' + from_stm + where_stm, con=conn)
	conn.close()
	return df_events_qry

def createDataset(df_events_qry):
	"""
	Esta función transforma la salida del query a la BBDD en un dataset que pueda ser usado para entrenar
	"""
	df_events_qry.dropna(inplace=True)
	df_events = df_events_qry.pivot_table(index=['ts','state'], columns='sensor_type_id', values='value', aggfunc=np.mean)
	df_events = df_events.reset_index().rename_axis(None, axis=1)
	df_events.rename(columns={'ts': 'TIMESTAMP', 'state': 'LUX_ON'},inplace=True)
	df_events.columns = [ 'TIMESTAMP', 'LUX_ON']+[ sensorIdToStr(colname) for colname in df_events.columns[2:] ]
	if df_events.isnull().values.any():
		df_events.dropna(inplace=True)
	
	del df_events['LUX_ACS']
	df_events['MOVEMENT'] = df_events.MOVEMENT.astype(int)
	df_events['LUX_ON'] = df_events['LUX_ON'].replace(2, 0)
	df_events['LUX_ON'] = df_events['LUX_ON'].replace(3, 1)
	df_events['WEEKDAY'] = df_events['TIMESTAMP'].dt.weekday
	df_events['HOUR'] = df_events['TIMESTAMP'].dt.hour
	
	# Normalización de los datos
	df_events['LIGHT'] = normalizar(minMax['light'][0], minMax['light'][1], df_events['LIGHT'])
	df_events['SOUND'] = normalizar(minMax['sound'][0], minMax['sound'][1], df_events['SOUND'])
	df_events['WEEKDAY'] = normalizar(minMax['day'][0], minMax['day'][1], df_events['WEEKDAY'])
	df_events['HOUR'] = normalizar(minMax['hour'][0], minMax['hour'][1], df_events['HOUR'])	
	
	df_events['LIGHT_1m'] = df_events.LIGHT.shift(1)
	df_events['MOVEMENT_CHANGE'] = df_events.MOVEMENT.diff()
	df_events['MOVEMENT_1m'] = df_events.MOVEMENT.shift(1)
	df_events['MOVEMENT_5m'] = df_events.MOVEMENT.rolling(5).sum() / 5
	df_events['MOVEMENT_15m'] = df_events.MOVEMENT.rolling(15).sum() / 15

	df_events['LUX_SWITCH'] = df_events.LUX_ON.diff()
	df_events = df_events[1:]
	
	#df_events.at[0, 'LIGHT_1m'] = df_events.at[0, 'LIGHT']
	#df_events.at[0, 'LUX_SWITCH'] = 0
	#df_events.at[0, 'LIGHT_LAST_STATE'] = df_events.at[0, 'LIGHT']
	#df_events.at[1, 'LIGHT_LAST_STATE'] = df_events.at[0, 'LIGHT']
	
	df_events['LUX_SWITCH'] = df_events.LUX_ON.diff()
	#df_events['LIGHT_LAST_STATE'] = df_events.query("LUX_SWITCH != 0 and LIGHT_LAST_STATE != LIGHT_LAST_STATE").LIGHT_1m
	df_events['LIGHT_LAST_STATE'] = df_events.query('LUX_SWITCH != 0').LIGHT_1m
	df_events['LIGHT_LAST_STATE'] = df_events['LIGHT_LAST_STATE'].fillna(method='pad')
	df_events.dropna(inplace=True)	
	return df_events
	

#------- Acá empiezan las definiciones de los métodos que están publicados -------#

# Método para mostrar root, la documentación de los métodos que siguen a continuación
def displayRoot():
	with open('/home/pi/rnaEngine/index.html', 'r') as content_file:
		content = content_file.read()
	return content
	   
# Método para solicitar cambio de estado de un módulo
def change(moduleId):
	state = connexion.request.args.get("state")	
	ovr = connexion.request.args.get("ovr")
	if not ovr:
		ovr = 0 
		
	if moduleId not in range(1, 256) or moduleId not in getValidModules():
		return { 
			'detail': 'Module ' + str(moduleId)+' does not exist',
			'title': 'Module does not exist',
			'status': 404 
		}, 404
		
	deviceId = getOwnerDevice(moduleId)
	if deviceId not in getValidDevices():
		return {
			'detail': 'Device '+str(deviceId)+' does not exist',
			'title': 'Device does not exist or not enabled',
			'status': 404
		}, 404
		
	command = ["/usr/local/bin/dqrSender", "A", str(deviceId)[0], str(moduleId), str(state), str(ovr)]
	process= subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
	exitCode = int(process.stdout.read())
	if exitCode == 0:
		return {
			'detail': 'State change sent and received by device '+str(deviceId),
			'title': 'Message sent',
			'status': 0
		}, 200
	else:
		return {
			'detail': 'State change request was sent but not received by device '+str(deviceId),
			'title': 'Message could not be sent',
			'status': 1
		}, 200

# Método para enviar un pedido de actualización de estado de un dispositivo
def query(deviceId):
		if deviceId not in range(0, 256):
			return { 
				'detail': str(deviceId)+' is not a valid device id',
				'title': 'Invalid request',
				'status': 400 
			}, 400
		if deviceId not in getValidDevices():
			return {
				'detail': 'Device '+str(deviceId)+' does not exist',
				'title': 'Invalid id',
				'status': 404
			}, 404
			
		process = subprocess.Popen(["/usr/local/bin/dqrSender", "S", str(deviceId)], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
		exitCode = int(process.stdout.read())
		if exitCode == 0:
			return {
				'detail': 'Query message sent and received by device '+str(deviceId),
				'title': 'Message sent',
				'status': 0
			}, 200
		else:
			return {
				'detail': 'Query message was sent but not received by device '+str(deviceId),
				'title': 'Message could not be sent',
				'status': 1
			}, 200

# Método para sugerir un estado de módulo
def getSuggestedState(moduleId):
	"""
	Consultar el estado sugerido de un dispositivo Lux
	Método para consultar el estado sugerido de un dispositivo DqR Lux, en un momento dado
	:param moduleId: ID del dispositivo
	:type moduleId: int
	
	:rtype: None
	"""
	if moduleId not in range(1, 256) or moduleId not in getValidModules():
		return { 
			'detail': 'Module ' + str(moduleId)+' does not exist',
			'title': 'Module does not exist',
			'status': 404 
		}, 404
	
	deviceId = getOwnerDevice(moduleId)
	if deviceId not in getValidDevices():
		return {
			'detail': 'Device '+str(deviceId)+' does not exist',
			'title': 'Device does not exist or not enabled',
			'status': 404
		}, 404

	if moduleId not in rnaDict.keys():
		return {
			'detail': 'Can\'t suggest anything: No trained model exists for module '+str(moduleId),
			'title': 'Can\'t suggest',
			'rnaDictKeys': str(rnaDict.keys()),
			'status': 404
		}, 404	

	# Obtener los datos de la BBDD
	print("Extracting events data from database")
	dbData = getDataFromDB(deviceId, moduleId, "minutes")
	try:
		print("Data extraction from database completed:",dbData.shape)
	except:
		print("Could not get data from database")
		return { 
			'detail': 'Error extracting data from database',
			'title': 'Database access error',
			'status': 1 
		}, 200
	
	# Verificar que hayan vuelto datos de la consulta.
	if len(dbData.index) == 0:
		return {
			'detail': 'Not enough recent data to suggest anything for module ' + str(moduleId),
			'title': ' Not enough data',
			'dbDataShape': dbData.shape,
			'status': 127
		}, 404
	
	# Transformar los datos en un dataset
	df_events = createDataset(dbData)
	df_events.drop(df_events.index[-1])
	del df_events['TIMESTAMP']
	del df_events['LUX_ON']
	del df_events['LIGHT']
	del df_events['LIGHT_1m']
	del df_events['MOVEMENT_CHANGE']
	del df_events['LUX_SWITCH']
	
	# Predicción
	clf_predict_new_test = rnaDict[moduleId]['model'].predict(df_events)
	
	return { 
		'title': 'Prediction Completed',
		'df_eventsShape': str(df_events.shape),
		'suggestedState': int(clf_predict_new_test[0])
		#'probeRow': str(df_events.tail(1)[0])
	}, 200

# Método para sugerir un cambio de estado de un módulo
def getSuggestedStateChange(moduleId):
	"""
	Consultar cambio de estado sugerido de un dispositivo Lux
	Método para consultar si hay un cambio estado sugerido  de un dispositivo DqR Lux, en un momento dado
	:param moduleId: ID del dispositivo
	:type moduleId: int
	
	:rtype: None
	"""
	return moduleId

# Método para entrenar
def train(moduleId):
	"""
	Realizar el entrenamiento para un dispositivo Lux
	Método para realizar el entrenamiento de la RNA para un dispositivo Lux en particular
	:param moduleId: ID del dispositivo
	:type moduleId: int
	:rtype: None
	"""
	if moduleId not in range(1, 256) or moduleId not in getValidModules():
		return { 
			'detail': 'Module ' + str(moduleId)+' does not exist',
			'title': 'Module does not exist',
			'status': 404 
		}, 404
	
	deviceId = getOwnerDevice(moduleId)
	if deviceId not in getValidDevices():
		return {
			'detail': 'Device '+str(deviceId)+' does not exist',
			'title': 'Device does not exist or not enabled',
			'status': 404
		}, 404

	print("Will create a neural network for module",moduleId)

	# Obtener los datos de la BBDD
	print("Extracting events data from database")
	dbData = getDataFromDB(deviceId, moduleId, "months")
	try:
		print("Data extraction from database completed:",dbData.shape)
	except:
		print("Could not get data from database")
		return { 
			'detail': 'Error extracting data from database',
			'title': 'Database access error',
			'status': 1 
		}, 200
		
	# Transformar los datos en un dataset
	df_events = createDataset(dbData)
	
	# Impresión de la proporcion on/off en el dataset
	print("Events proportion on dataset:")
	print(df_events.LUX_ON.value_counts(normalize=True))
	
	# --- Entrenamiento Inicial del modelo de estado ---
	print("Starting data preparation of the state change model")
	luxState_feature_names = ['WEEKDAY', 'HOUR', 'SOUND', 'MOVEMENT', 'MOVEMENT_1m', 'MOVEMENT_5m', 'MOVEMENT_15m', 'LIGHT_LAST_STATE']
	luxState_goal_names = ['LUX_ON']
	luxState_features = df_events[luxState_feature_names].values     # Columnas del predictor (8 X m)
	luxState_goal = df_events[luxState_goal_names].values            # Clase predecida (1=verdadero, 0=falso) column (1 X m)
	split_test_size = 0.30                                           # 0.30 es 30%, el tamaño para pruebas
	luxState_features_train, luxState_features_test, luxState_goal_train, luxState_goal_test = train_test_split(luxState_features, luxState_goal, test_size=split_test_size)

	print("Data proportion after train/test split:")
	print("{0:.2f}% on training set".format( (float(len(luxState_features_train))/len(df_events.index)) * 100 ) )
	print("{0:.2f}% on test set".format((float(len(luxState_features_test))/len(df_events.index)) * 100))
	print("")
	print("Lux Active on total          : {0} ({1:0.2f}%)".format(len(df_events.loc[df_events['LUX_ON'] == 1]), (len(df_events.loc[df_events['LUX_ON'] == 1])/float(len(df_events.index))) * 100.0))
	print("Lux Inactive on total        : {0} ({1:0.2f}%)".format(len(df_events.loc[df_events['LUX_ON'] == 0]), (len(df_events.loc[df_events['LUX_ON'] == 0])/float(len(df_events.index))) * 100.0))
	print("")
	train_state_on = len(luxState_goal_train[ luxState_goal_train == 1])
	train_state_off = len(luxState_goal_train[ luxState_goal_train == 0])
	print("Lux Active on training       : {0} ({1:0.2f}%)".format(train_state_on, train_state_on/float(len(luxState_goal_train)) * 100.0))
	print("Lux Inactive on training     : {0} ({1:0.2f}%)".format(train_state_off, train_state_off/float(len(luxState_goal_train)) * 100.0))
	print("")
	test_state_on = len(luxState_goal_test[ luxState_goal_test == 1])
	test_state_off = len(luxState_goal_test[ luxState_goal_test == 0])
	print("Lux Active on test           : {0} ({1:0.2f}%)".format(test_state_on, test_state_on/float(len(luxState_goal_test)) * 100.0))
	print("Lux Inactive on test         : {0} ({1:0.2f}%)".format(test_state_off,test_state_off/float(len(luxState_goal_test)) * 100.0))
	print("")
	
	print("Training Neural Network Classifier for State change model...")
	clf_model_state = MLPClassifier()
	clf_model_state.fit(luxState_features_train, luxState_goal_train.ravel())
	
	# Performance del modelo de estado con datos de entrenamiento
	clf_predict_state_train = clf_model_state.predict(luxState_features_train)
	print("Precisión del modelo de estado en entrenamiento: {0:.4f}".format(metrics.accuracy_score(luxState_goal_train, clf_predict_state_train)))
	
	# Performance del modelo de estado con datos de prueba
	clf_predict_state_test = clf_model_state.predict(luxState_features_test)
	print("Precisión del modelo de estado en test: {0:.4f}".format(metrics.accuracy_score(luxState_goal_test, clf_predict_state_test)))
	
	# Matriz de confusión del modelo de estado
	print("Matriz de confusión del modelo de estado:")
	confMatrix = metrics.confusion_matrix(luxState_goal_test, clf_predict_state_test, labels=[1, 0])
	print("{0}".format(confMatrix))
	
	# Reporte de clasificación del modelo de estado
	print("Reporte de clasificación del modelo de estado:")
	classReport = metrics.classification_report(luxState_goal_test, clf_predict_state_test, labels=[1,0])
	print(classReport)
	
	rnaDict.update( {
		moduleId: {
			'model': clf_model_state,
			'features': luxState_features_test,
			'goal': luxState_goal_test
			}
		} )
	
	return {
		'detail': 'Trained model created for module '+str(moduleId),
		'confMatrix': str(confMatrix),
		'title': 'Model created',
		'status': 0

	}, 200

# Método para verificar si el entrenamiento existe para un dispositivo dado
def isTrained(moduleId):
	"""
	Validar si existe una RNA entrenada con datos correspondientes al módulo
	provisto.
	:param moduleId: ID del dispositivo
	:type moduleId: int
	:rtype: None
	"""
	print(rnaDict)
	if moduleId in rnaDict.keys():
		return {
			'detail': 'Trained model exists for module '+str(moduleId),
			'title': 'Model found',
			'status': 0
			#'confussionMatrix': rnaDict[moduleId].get("confMatrix"),
			#'classificationReport': rnaDict[moduleId].get("classReport")
		}, 200
	else:
		return {
			'detail': 'No trained model exists for module '+str(moduleId),
			'title': 'Model does not exist',
			'status': 404
		}, 404

# Métodos para guardar, cargar, y borrar los modelos entrenados a/de/del disco
def load():
	rnaFile = '/home/pi/dqr/rnaEngine/.trainedModels'
	global rnaDict
	try:
		rnaDict = joblib.load(rnaFile)
	except FileNotFoundError:
		return {
			'status': 1,
			'title': 'No models found',
			'detail': 'Attempt to load trained models from disk failed, file does not exist'
		}, 404

	return {
		'status': 0,
		'title': 'Trained models loaded',
		'detail': 'Trained models have been loaded from disk, see moduleIds field for details',
		'moduleIds': list(rnaDict.keys())
	}, 200
		
def purge():
	global rnaDict
	rnaDict = {}
	rnaFile = '/home/pi/dqr/rnaEngine/.trainedModels'
	remove(rnaFile)
	return {
		'status': 0,
		'title': 'Trained models purged',
		'detail': 'Trained models have been purged from memory and disk'	
	}
	
def save():
	if len(rnaDict.keys()) == 0:
		return {
			'status': 404,
			'title': 'Training models not found',
			'detail': 'Save requested, but there\'s no model created to be saved'
		}, 404

	try:
		rnaFile = '/home/pi/dqr/rnaEngine/.trainedModels'
		joblib.dump(rnaDict, rnaFile)
	except:
		return {
			'status': 400,
			'title': 'Error saving to disk',
			'detail': 'There was an error when saving models to disk. Retry this operation at a later time.'
		}, 400
		
	return {
		'status': 0,
		'title': 'Trained models saved',
		'detail': 'All current trained models have been saved to disk, see moduleIds field for details',
		'moduleIds': list(rnaDict.keys())
	}, 200
	
	
# ---- Inicio de la API ---
#
# No se hace training inicial. Cuando un dispositivo se marque para uso inteligente, se debe llamar
# al método train con el parametro moduleId
#
rnaDict = {} 
