#
# Definición de los métodos para predecir el estado de un dispositivo Lux
#

import connexion
from datetime import date, datetime
from typing import List, Dict
from six import iteritems
from ..util import deserialize_date, deserialize_datetime
import subprocess 
import MySQLdb

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPClassifier
from sklearn import metrics


# Funcion para pasar de sensor_id a nombre
def sensorIdToStr(sensor_id):
	sensors = { 
		1: 'LUX_ACS',
		2: 'LIGHT',
		3: 'MOVEMENT',
		4: 'SOUND',
		5: 'TEMPERATURE'
	}	
	return sensors[sensor_id]

# Función para normalizar entre -1 y 1 en base a máximos y mínimos de un sensor	
def normalizar(min, max, value):
    return 2*(value - min)/(max - min) - 1

# Función para desnormalizar
def desnormalizar(min, max, value):
    return (value+1)*(max - min)/2 + min

# Conexión a la BBDD
def getDBConnection():
	dbname = "ratio_dev"
	dbhost = "localhost"
	dbport = 3306
	dbuser = "root"
	dbpass = "root"
	try:
		conn = MySQLdb.connect(host=dbhost, port=dbport, user=dbuser, passwd=dbpass, db=dbname)
		return conn
	except:
		print("Error conectando a BBDD",dbname)
		return -1

# Función para obtener los dispositivos válidos (registrados, no borrados y activos)
def getValidDevices():
	"""
	Update the list of existing devices based on what's on the database
	"""
	conn = getDBConnection()
	cur = conn.cursor()
	cur.execute('select id from devices where deleted = 0 and disabled = 0')
	devices = [ row[0] for row in cur.fetchall() ]
	conn.close()
	return devices

# Función para obtener el device al que pertenece un modulos
def getOwnerDevice(moduleId):
	conn = getDBConnection()
	cur = conn.cursor()
	cur.execute('select device_id from device_modules where id = '+str(moduleId))
	device = cur.fetchall()[0][0]
	conn.close()
	return device
	
# Función para obtener los modulos válidos
def getValidModules():
	"""
	Update the list of existing modules based on what's on the database
	"""
	conn = getDBConnection()
	cur = conn.cursor()
	cur.execute('select id from device_modules')
	modules = [ row[0] for row in cur.fetchall() ]
	conn.close()
	return modules

# Método para solicitar cambio de estado de un módulo
def change_module_state(moduleId):
	state = connexion.request.args.get("state")	
	ovr = connexion.request.args.get("ovr")
	if not ovr:
		ovr = 0 
		
	if moduleId not in range(1, 256) or moduleId not in getValidModules():
		return { 
			'detail': 'Module ' + str(moduleId)+' does not exist',
			'title': 'Module does not exist',
			'status': 404 
		}, 404
		
	deviceId = getOwnerDevice(moduleId)
	if deviceId not in getValidDevices():
		return {
			'detail': 'Device '+str(deviceId)+' does not exist',
			'title': 'Device does not exist or not enabled',
			'status': 404
		}, 404
		
	command = ["/usr/local/bin/dqrSender", "A", str(deviceId)[0], str(moduleId), str(state), str(ovr)]
	process= subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
	exitCode = int(process.stdout.read())
	if exitCode == 0:
		return {
			'detail': 'State change sent and received by device '+str(deviceId),
			'title': 'Message sent',
			'status': 0
		}, 200
	else:
		return {
			'detail': 'State change request was sent but not received by device '+str(deviceId),
			'title': 'Message could not be sent',
			'status': 1
		}, 200

# Método para enviar un pedido de actualización de estado de un dispositivo
def query_device_state(deviceId):
		if deviceId not in range(0, 256):
			return { 
				'detail': str(deviceId)+' is not a valid device id',
				'title': 'Invalid request',
				'status': 400 
			}, 400
		if deviceId not in getValidDevices():
			return {
				'detail': 'Device '+str(deviceId)+' does not exist',
				'title': 'Invalid id',
				'status': 404
			}, 404
			
		process = subprocess.Popen(["/usr/local/bin/dqrSender", "S", str(deviceId)], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
		exitCode = int(process.stdout.read())
		if exitCode == 0:
			return {
				'detail': 'Query message sent and received by device '+str(deviceId),
				'title': 'Message sent',
				'status': 0
			}, 200
		else:
			return {
				'detail': 'Query message was sent but not received by device '+str(deviceId),
				'title': 'Message could not be sent',
				'status': 1
			}, 200

# Función para importar el dataset desde la tabla dwh
def getDataFromDB(luxId):
	device_events_tbl = "device_events"
	device_event_sensors_tbl = "device_event_sensors"
	device_modules_tbl = "device_modules"


	print("Extrayendo datos del dispositivo",luxId)
	# Extracción de datos
	conn = MySQLdb.connect(host=dbhost_hist, port=dbport_hist, user=dbuser_hist, passwd=dbpass_hist, db=dbname_hist)
	from_stm = 'FROM ' + device_events_tbl + ' de LEFT JOIN ' + device_event_sensors_tbl + ' des ON de.id=des.device_event_id '
	where_stm = 'WHERE deviceId = ' + str(luxId/10) + ' AND module_id = ' + str(luxId) + ' AND ts BETWEEN DATE_SUB(NOW(), INTERVAL 90 DAY) AND NOW()'
	df_events_qry = pd.read_sql('select ts, state, sensor_type_id, value ' + from_stm + where_stm, con=conn)
	conn.close()
	return df_events_qry

def createDataset(df_events_qry):
	"""
	Esta función transforma la salida del query a la BBDD en un dataset que pueda ser usado para entrenar
	"""
	df_events_qry.dropna(inplace=True)
	df_events = df_events_qry.pivot_table(index=['ts','state'], columns='sensor_type_id', values='value', aggfunc=np.mean)
	df_events = df_events.reset_index().rename_axis(None, axis=1)
	df_events.rename(columns={'ts': 'TIMESTAMP', 'state': 'LUX_ON'},inplace=True)
	df_events.columns = [ sensorIdToStr(colname) for colname in df_events.columns ]
	df_events.dropna(inplace=True)
	del df_events['LUX_ACS']
	df_events['MOVEMENT'] = df_events.MOVEMENT.astype(int)
	df_events['LUX_ON'] = df_events['LUX_ON'].replace(2, 0)
	df_events['LUX_ON'] = df_events['LUX_ON'].replace(3, 1)
	df_events['WEEKDAY'] = df_events['TIMESTAMP'].dt.weekday
	df_events['HOUR'] = df_events['TIMESTAMP'].dt.hour
	
	# Normalización
	minMax = { 'light': [df_events.min()[2], df_events.max()[2]], 
           'sound': [df_events.min()[4], df_events.max()[4]],
           'day': [ 0, 6 ],
           'hour': [ 0, 23 ]
         }	
	df_events['LIGHT'] = normalizar(minMax['light'][0], minMax['light'][1], df_events['LIGHT'])
	df_events['SOUND'] = normalizar(minMax['sound'][0], minMax['sound'][1], df_events['SOUND'])
	df_events['WEEKDAY'] = normalizar(minMax['day'][0], minMax['day'][1], df_events['WEEKDAY'])
	df_events['HOUR'] = normalizar(minMax['hour'][0], minMax['hour'][1], df_events['HOUR'])

	return df_events

def get_suggested_state(moduleId):
	"""
	Consultar el estado sugerido de un dispositivo Lux
	Método para consultar el estado sugerido de un dispositivo DqR Lux, en un momento dado
	:param moduleId: ID del dispositivo
	:type moduleId: int
	
	:rtype: None
	"""
	return moduleId

def get_suggested_state_change(moduleId):
	"""
	Consultar cambio de estado sugerido de un dispositivo Lux
	Método para consultar si hay un cambio estado sugerido  de un dispositivo DqR Lux, en un momento dado
	:param moduleId: ID del dispositivo
	:type moduleId: int
	
	:rtype: None
	"""
	return moduleId

# Método para entrenar
def do_training(moduleId):
	"""
	Realizar el entrenamiento para un dispositivo Lux
	Método para realizar el entrenamiento de la RNA para un dispositivo Lux en particular
	:param moduleId: ID del dispositivo
	:type moduleId: int
	:rtype: None
	"""
	
	# Obtener los datos del dwh
	dbData = getDataFromDB(moduleId)
	try:
		print("Data extraction from database completed:",dbData.shape())
	except:
		print("Could not ")
		return -1
	
	# Transformar los datos en un dataset
	df_events = createDataset(dbData)
	
	# Impresión de la proporcion on/off en el dataset
	print("Proporción de datos en el dataset:")
	df_events.LUX_SWITCH.value_counts(normalize=True)
	
	# --- Entrenamiento Inicial del modelo de estado ---
	print("Entrenamiento del modelo de cambio de estado")
	print("Preparación de los datos")
	luxState_feature_names = ['WEEKDAY', 'MINDAY', 'LIGHT_LUX_1m', 'SOUND', 'MOVEMENT', 'MOVEMENT_1m', 'MOVEMENT_5m', 'MOVEMENT_15m']
	luxState_goal_names = ['LUX_ON']
	luxState_features = df_events[luxState_feature_names].values     # Columnas del predictor (5 X m)
	luxState_goal = df_events[luxState_goal_names].values            # Clase predecida (1=verdadero, 0=falso) column (1 X m)
	split_test_size = 0.30                                           # 0.30 es 30%, el tamaño para pruebas
	luxState_features_train, luxState_features_test, luxState_goal_train, luxState_goal_test = train_test_split(luxState_features, luxState_goal, test_size=split_test_size)
	
	print("Lux Activo en el total           : {0} ({1:0.2f}%)".format(len(df_events.loc[df_events['LUX_ON'] == 1]), (len(df_events.loc[df_events['LUX_ON'] == 1])/float(len(df_events.index))) * 100.0))
	print("Lux Inactivo en el total         : {0} ({1:0.2f}%)".format(len(df_events.loc[df_events['LUX_ON'] == 0]), (len(df_events.loc[df_events['LUX_ON'] == 0])/float(len(df_events.index))) * 100.0))
	train_state_on = len(luxState_goal_train[ luxState_goal_train == 1])
	train_state_off = len(luxState_goal_train[ luxState_goal_train == 0])
	print("Lux Activo en entrenamiento      : {0} ({1:0.2f}%)".format(train_state_on, train_state_on/float(len(luxState_goal_train)) * 100.0))
	print("Lux Inctivo en entrenamiento     : {0} ({1:0.2f}%)".format(train_state_off, train_state_off/float(len(luxState_goal_train)) * 100.0))
	test_state_on = len(luxState_goal_test[ luxState_goal_test == 1])
	test_state_off = len(luxState_goal_test[ luxState_goal_test == 0])
	print("Lux Activo en test               : {0} ({1:0.2f}%)".format(test_state_on, test_state_on/float(len(luxState_goal_test)) * 100.0))
	print("Lux Inctivo en test              : {0} ({1:0.2f}%)".format(test_state_off,test_state_off/float(len(luxState_goal_test)) * 100.0))
	print("")
	
	print("Entrenando RNA-Classifier para modelo de estado...")
	clf_model_state = MLPClassifier()
	clf_model_state.fit(luxState_features_train, luxState_goal_train.ravel())
	
	# Performance del modelo de estado con datos de entrenamiento
	clf_predict_state_train = clf_model_state.predict(luxState_features_train)
	print("Precisión del modelo de estado en entrenamiento: {0:.4f}".format(metrics.accuracy_score(luxState_goal_train, clf_predict_state_train)))
	
	# Performance del modelo de estado con datos de prueba
	clf_predict_state_test = clf_model_state.predict(luxState_features_test)
	print("Precisión del modelo de estado en test: {0:.4f}".format(metrics.accuracy_score(luxState_goal_test, clf_predict_state_test)))
	
	# Matriz de confusión del modelo de estado
	print("Matriz de confusión del modelo de estado:")
	print("{0}".format(metrics.confusion_matrix(luxState_goal_test, clf_predict_state_test, labels=[1, 0])))
	
	# Reporte de clasificación del modelo de estado
	print("Reporte de clasificación del modelo de estado:")
	print(metrics.classification_report(luxState_goal_test, clf_predict_state_test, labels=[1,0]))
	
	
	# --- Entrenamiento Inicial del modelo de cambio de estado ---
	print("Entrenamiento del modelo de cambio de estado")
	print("Preparación de los datos")
	luxSwitch_feature_names = ['WEEKDAY', 'MINDAY', 'LIGHT_LUX_1m', 'SOUND', 'MOVEMENT', 'MOVEMENT_1m', 'MOVEMENT_5m', 'MOVEMENT_15m' ]
	luxSwitch_goal_names = ['LUX_SWITCH']
	luxSwitch_features = df_events[luxSwitch_feature_names].values        # Columnas predictoras
	luxSwitch_goal = df_events[luxSwitch_goal_names].values               # Clase predecida (1, 0, -1)
	split_test_size = 0.30                                                # 0.30 es 30%, el tamaño para pruebas
	luxSwitch_feat_train, luxSwitch_feat_test, luxSwitch_goal_train, luxSwitch_goal_test = train_test_split(luxSwitch_features, luxSwitch_goal, test_size=split_test_size)
	
	totales_switch_on = len(df_events.query('LUX_SWITCH == 1'))
	totales_switch_stale = len(df_events.query('LUX_SWITCH == 0'))
	totales_switch_off = len(df_events.query('LUX_SWITCH == -1'))
	print('Totales:')
	print("Prendidas        : {0} ({1:0.2f}%)".format(totales_switch_on, totales_switch_on/float(df_events.shape[0]) * 100.0))
	print("Sin cambios      : {0} ({1:0.2f}%)".format(totales_switch_stale, totales_switch_stale/float(df_events.shape[0]) * 100.0))
	print("Apagadas         : {0} ({1:0.2f}%)".format(totales_switch_off, totales_switch_off/float(df_events.shape[0]) * 100.0))
	train_switch_on = len(luxSwitch_goal_train[ luxSwitch_goal_train == 1])
	train_switch_stale = len(luxSwitch_goal_train[ luxSwitch_goal_train == 0])
	train_switch_off = len(luxSwitch_goal_train[ luxSwitch_goal_train == -1])
	print('Set de entrenamiento:')
	print("Prendidas        : {0} ({1:0.2f}%)".format(train_switch_on, train_switch_on/float(luxSwitch_goal_train.shape[0]) * 100.0))
	print("Sin cambios      : {0} ({1:0.2f}%)".format(train_switch_stale, train_switch_stale/float(luxSwitch_goal_train.shape[0]) * 100.0))
	print("Apagadas         : {0} ({1:0.2f}%)".format(train_switch_off, train_switch_off/float(luxSwitch_goal_train.shape[0]) * 100.0))
	test_switch_on = len(luxSwitch_goal_test[ luxSwitch_goal_test == 1])
	test_switch_stale = len(luxSwitch_goal_test[ luxSwitch_goal_test == 0])
	test_switch_off = len(luxSwitch_goal_test[ luxSwitch_goal_test == -1])
	print('Set de pruebas:')
	print("Prendidas        : {0} ({1:0.2f}%)".format(test_switch_on, test_switch_on/float(luxSwitch_goal_test.shape[0]) * 100.0))
	print("Sin cambios      : {0} ({1:0.2f}%)".format(test_switch_stale, test_switch_stale/float(luxSwitch_goal_test.shape[0]) * 100.0))
	print("Apagadas         : {0} ({1:0.2f}%)".format(test_switch_off, test_switch_off/float(luxSwitch_goal_test.shape[0]) * 100.0))
	print("")
	
	print("Entrenando RNA-Classifier para modelo de cambio de estado...")
	clf_model_switch = MLPClassifier()
	clf_model_switch.fit(luxSwitch_feat_train, luxSwitch_goal_train.ravel())
	
	# Performance con datos de entrenamiento
	clf_predict_switch_train = clf_model_switch.predict(luxSwitch_feat_train)
	print("Precisión del modelo de cambio de estado en entrenamiento: {0:.4f}".format(metrics.accuracy_score(luxSwitch_goal_train, clf_predict_switch_train)))
	
	# Performance con datos de prueba
	clf_predict_switch_test = clf_model_switch.predict(luxSwitch_feat_test)
	print("Precisión del modelo de cambio de estado en test: {0:.4f}".format(metrics.accuracy_score(luxSwitch_goal_test, clf_predict_switch_test)))
	
	# Matriz de confusión
	print("Matriz de confusión del modelo de cambio de estado:")
	print("{0}".format(metrics.confusion_matrix(luxSwitch_goal_test, clf_predict_switch_test, labels=[1, 0, -1])))
	
	# Reporte de clasificación
	print("Reporte de clasificación del modelo de cambio de estado:")
	print(metrics.classification_report(luxSwitch_goal_test, clf_predict_switch_test, labels=[1,0,-1]))
	
	models.update({moduleId: [clf_model_state, clf_model_switch]})

# Método para verificar si el entrenamiento existe para un dispositivo dado
def check_training(moduleId):
	"""
	Validar si existe una RNA entrenada con datos correspondientes al módulo
	provisto.
	:param moduleId: ID del dispositivo
	:type moduleId: int
	:rtype: None
	"""
	if moduleId in rnaArray.keys():
		return {
			'detail': 'Trained model exists for module '+str(moduleId),
			'title': 'Model found',
			'status': 0
		}, 200
	else:
		return {
			'detail': 'No trained model exists for module '+str(moduleId),
			'title': 'Model does not exist',
			'status': 404
		}, 404


# ---- Inicio de la API ---
#
# No se hace training inicial. Cuando un dispositivo se marque para uso inteligente, se debe llamar
# al método train con el parametro moduleId
#
rnaArray = {} 
